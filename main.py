import socket
from typing import Dict, Callable, Tuple

from views import *

URLS: Dict[str, Callable[[], str]] = {
    '/': index,
    '/blog': blog
}


def parse_request(request: str) -> Tuple[str, str]:
    """
    The function takes a string representing an HTTP request and returns a tuple containing the request method and URL.

    :param request: The `request` parameter is a string that represents an HTTP request.
    It typically includes information. Such as the HTTP method (e.g. GET, POST),
    the URL being requested, and any headers or data associated with the request
    :type request: str
    :return: A tuple containing two strings - the HTTP method and the URL parsed from the input request string.
    """
    parsed = request.split(' ')
    method, url = parsed[0], parsed[1]

    return method, url


def generate_headers(method: str, url: str) -> Tuple[str, int]:
    """
    This function generates HTTP headers based on the provided method and URL,
    returning a tuple with the header string and corresponding status code.

    :param method: a string representing the HTTP method (e.g. GET, POST, PUT, DELETE)
    :type method: str
    :param url: The URL parameter is a string that represents the URL being requested by the client
    :type url: str
    :return: A tuple containing a string representing an HTTP response header and an integer representing
    the HTTP status code. The contents of the tuple depend on the input parameters `method` and `url`.
    If `method` is not 'GET', the header string will indicate a 405 Method not allowed error and
    the status code will be 405. If `url` is not in the `URLS` list
    """
    if not method == 'GET':
        return 'HTTP/1.0 405 Method not allowed\n\n', 405

    if not url in URLS:
        return 'HTTP/1.0 405 Not found\n\n', 404

    return 'HTTP/1.0 200 OK\n\n', 200


def generate_content(code: int, url: str) -> str:
    """
    The function generates content based on the input code and URL, returning specific HTML code for 404 and 405 errors
    and calling a dictionary of URL functions for other cases.

    :param code: an integer representing the HTTP status code of a request
    :type code: int
    :param url: The `url` parameter is a string that represents the URL of a webpage
    :type url: str
    :return: The function `generate_content` takes two arguments, an integer `code` and a string `url`, and returns a
    string.
    """

    if code == 404:
        return '<h1>404</h1><p>Not found</p>'
    if code == 405:
        return '<h1>405</h1><p>Method not allowed</p>'

    return URLS[url]()


def generate_response(request: str) -> bytes:
    """
    This function generates a response to an HTTP request by parsing the request, generating headers and content, and
    encoding the response.

    :param request: The request parameter is a string that represents an HTTP request.
    It typically includes information such as the HTTP method (e.g. GET, POST), the URL being requested,
    and any headers or data associated with the request
    :type request: str
    :return: The function `generate_response` is returning a bytes object which is a concatenation of the headers
    and body generated by the `generate_headers` and `generate_content` functions respectively.
    The headers and body are first concatenated as a string and then encoded as bytes before being returned.
    """

    method, url = parse_request(request)
    headers, code = generate_headers(method, url)
    body = generate_content(code, url)

    return (headers + body).encode()


def run() -> None:
    """
    This function creates a server socket that listens for incoming connections, receives requests from clients,
    generates a response, and sends it back to the client before closing the connection.
    """

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # IPv4 , TCP
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)   # Указание на наш сокет, addr reuse = True
    server_socket.bind(('localhost', 5000))
    server_socket.listen()

    while True:
        client_socket, addr = server_socket.accept()
        print(client_socket, addr)
        request: bytes = client_socket.recv(1024)
        print(request)
        print()
        print(addr)

        response = generate_response(request.decode('utf-8'))

        client_socket.sendall(response)
        client_socket.close()


if __name__ == '__main__':
    run()
